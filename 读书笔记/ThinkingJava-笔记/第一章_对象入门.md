# 1 抽象的进步

+ 所有东西都是对象。
+ 程序是一大堆对象的组合。
+ 通过封装现有对象，可制作出新型对象。
+ 每个对象都有一种类型。
+ 同一类所有对象都能接收相同的消息。

# 2 对象的接口

强调“类型”决定了接口，而“类”是那个接口的一种特殊实现方式。

每个对象仅能接受特定的请求。我们向对象发出的请求是通过它的“接口”（ Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。“类型”与“接口”的等价或对应关系是面向对象程序设计的基础。

# 3 实现方案的隐藏

Java 采用三个显式（明确）关键字以及一个隐式（暗示）关键字来设置类边界： public， private，protected 以及暗示性的 friendly。封装

# 4 方案的重复使用

新建类的时候，首先应考虑“组织”对象；这样做显得更加简单和灵活。利用对象的组织，我们的设计可保持清爽。

# 5 继承：重新使用接口

继承，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员，但更重要的是，它复制了基础类的接口。

## 1) 改善基础类

为衍生类的函数建立一个新定义即可

## 2) 等价与类似关系
等价 将衍生类的一个对象换成基础类的一个对象

类似 为衍生类型加入新的接口元素

# 6 多形对象的互换使用

将衍生类的对象当作基础类的一个对象对待

把衍生类型当作它的基本类型处理的过程叫作“ Upcasting”（上溯造型）

## 1) 动态绑定

将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫作“多形性”（ Polymorphism）。

对面向对象的程序设计语言来说，它们用以实现多形性的方法叫作“动态绑定”。

## 2) 抽象的基础类和接口

不想其他任何人实际创建基础类的一个对象，只对上溯造型成它，以便使用它们的接口。可以把那个类变成“抽象”的—— 使用 abstract 关键字。

亦可用 abstract 关键字描述一个尚未实现的方法，通过创建一个抽象方法，我们可以将一个方法置入接口中，不必再为那个方法提供可能毫无意义的主体代码。

interface（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。

# 7 对象的创建和存在时间

C++认为程序的执行效率是最重要的一个问题，为获得最快的运行速度，存储以及存在时间可在编写程序时决定，只需将对象放置在堆栈或者静态存储区域即可。这样便为存储空间的分配和释放提供了一个优先级。某些情况下，这种优先级的控制是非常有价值的。然而，我们同时也牺牲了灵活性，因为在编写程序时，必须知道对象的准确的数量、存在时间、以及类型。如果要解决的是一个较常规的问题，如计算机辅助设计、仓储管理或者空中交通控制，这一方法就显得太局限了。

第二个方法是在一个内存池中动态创建对象，该内存池亦叫“堆”或者“内存堆”。若需一个新对象，只需在需要它的时候在内存堆里简单地创建它即可。由于存储空间的管理是运行期间动态进行的，所以在内存堆里分配存储空间的时间比在堆栈里创建的时间长得多（在堆栈里创建存储空间一般只需要一个简单的指令，将堆栈指针向下或向下移动即可）。由于动态创建方法使对象本来就倾向于复杂，所以查找存储空间以及释放它所需的额外开销不会为对象的创建造成明显的影响。除此以外，更大的灵活性对于常规编程问题的解决是至关重要的。

若在堆栈或者静态存储空间里创建一个对象，编译器会判断对象的持续时间有多长，到时会自动“破坏”或者“清除”它。程序员可用两种方法来破坏一个对象：用程序化的方式决定何时破坏对象，或者利用由运行环境提供的一种“垃圾收集器”特性，自动寻找那些不再使用的对象，并将其清除。

## 1) 集合与继承器

集合会自动扩充自己，以便适应我们在其中置入的任何东西。

对集合中的一系列元素进行操纵或比较，而不是仅仅面向一个，办法就是使用一个“继续器”（Iterator），有的地方称为迭代器。继承器允许我们遍历那个序列，同时毋需关心基础结构是什么。

集合只是一个用来放置对象的储藏所。如果那个储藏所能满足我们的所有需要，就完全没必要关
心它具体是如何实现的。

## 2) 单根结构

单根结构中的所有对象都有一个通用接口，所以它们最终都属于相同的类型。一个单根结构，加上所有对象都在内存堆中创建，可以极大简化参数的传递。

利用单根结构，我们可以更方便地实现一个垃圾收集器。由于运行期的类型信息肯定存在于所有对象中，所以永远不会遇到判断不出一个对象的类型的情况。

为什么C++没有采用单根结构呢？会带来程序设计上的一些限制，主要是新程序与原有 C 代码兼容的难度。

## 3) 集合库与方便使用集合

一个集合库是十分必要的，它应该可以方便地重复使用。

**下溯造型与模板／通用性**

不是在分级结构中上溯造型成一种更“通用”的类型。而是下溯造型成一种更“特殊”的类型。这种造型方法叫作“下溯造型”（ Downcasting）。

可以采用“参数化类型”，它们是编译器能自动定制的类，可与特定的类型配合。

## 4) 清除时的困境：由谁负责清除

垃圾收集器“知道”一个对象在什么时候不再使用，然后会自动释放那个对象占据的内存空间。

在堆栈中创建对象是为对象分配存储空间最有效的一种方式，也是释放那些空间最有效的一种方式。

实时 Java 系统 : http://www.ptc.com/developer-tools/perc

# 8 违例控制：解决错误

“违例控制”将错误控制方案内置到程序设计语言中，有时甚至内建到操作系统内。随后，这个违例会被设计用于控制特定类型错误的“违例控制器”捕获。

注意违例控制并不属于一种面向对象的特性，尽管在面向对象的程序设计语言中，违例通常是用一个对象表示的。早在面向对象语言问世以前，违例控制就已经存在了。

# 9 多线程

将问题划分进入独立运行的程序片断中，使整个程序能更迅速地响应用户的请求。在一个程序中，这些独立运行的片断叫作“线程”（ Thread），利用它编程的概念就叫作“多线程处理”。

最开始，线程只是用于分配单个处理器的处理时间的一种工具。

Java 对多线程处理的支持是在对象这一级支持的，所以一个执行线程可表达为一个对象。 

Java 也提供了有限的资源锁定方案。它能锁定任何对象占用的内存（内存实际是多种共享资源的一种），所以同一时间只能有一个线程使用特定的内存空间。为达到这个目的，需要使用 synchronized 关键字。

# 10 永久性

有限永久性”的支持，这意味着我们可将对象简单地保存到磁盘上，以后任何时间都可取回。之所以称它为“有限”的，是由于我们仍然需要明确发出调用，进行对象的保存和取回工作。这些工作不能自动进行。

# 11 Java 和因特网

Java 除了可解决传统的程序设计问题以外，还能解决World Wide Web（万维网）上的编程问题。

## 1) 什么是 Web ？

+ 客户机／服务器计算

客户机／服务器系统的基本思想是我们能在一个统一的地方集中存放信息资源。根据其他人或者机器的请求将信息投递给对方。

信息是“集中存放”的。

+ Web 是一个巨大的服务器

Web 实际就是一套规模巨大的客户机／服务器系统。 -> Web 浏览器的发展。 -> 客户端编程。


## 2) 客户端编程

用户提交的信息通过所有Web 服务器均能支持的“通用网关接口”（ CGI）回传到服务器。

+ 插件

利用插件可以方便地为浏览器添加新功能。插件实际是浏览器的一个“后门”，允许创建新的客户端程序设计语言。

+ 脚本编制语言

插件造成了脚本编制语言的爆炸性增长。脚本语言真正面向的是特定类型问题的解决，其中主要涉及如何创建更丰富、更具有互动能力的图形用户界面（ GUI）。

JavaScript 是目前最常用的，它得到的支持也最全面。

+ Java

脚本编制语言能解决 80％的客户端程序设计问题，那么剩下的 20％又该怎么办呢？

 Java 通过“程序片”（ Applet ）巧妙地解决了客户端编程的问题。

+ ActiveX

ActiveX 最早是一种纯 Windows 的方案。

+ 安全

Applet 也设计成在一个安全“沙箱”里在它的程序片中运行。

ActiveX 编写程序就象编制 Windows 应用程序，解决的办法是“数字签名”。

+ 因特网和内联网

若一个信息网络局限于一家特定的公司，那么在将Web 技术应用于它之后，即可称其为“内联网”（ Intranet）。内联网提供了比因特网更大的安全级别，因为可以物理性地控制对公司内部服务器的使用。

## 3) 服务器端编程

基于 Java 的 Web 服务器，它允许我们用 Java 进行所有服务器端编程，写出的程序就叫作“小服务程序”（ Servlet）。

## 4) 一个独立的领域：应用程序

Java 提供了许多有用的特性，使我们能在较短的时间里创建出比用从前的程序设计语言更健壮的程序。

# 12 分析和设计

## 1) 不要迷失

+ 对象是什么？（怎样将自己的项目分割成一系列单独的组件？）
+ 它们的接口是什么？（需要将什么消息发给每一个对象？）

## 2) 阶段 0 ：拟出一个计划

决定在后面的过程中采取哪些步骤。

## 3) 阶段 1 ：要制作什么？

应尽可能总结出自己系统的一套完整的“使用条件”或者“应用场合”。一旦完成这个工作，就相当于摸清了想让系统完成的核心任务。

## 4) 阶段 2 ：如何构建？

必须拿出一套设计方案，并解释其中包含的各类对象在外观上是什么样子，以及相互间是如何沟通的。

可以使用“统一建模语言”（ UML）。完成对象以及接口的说明。

## 5) 阶段 3 ：开始创建

让代码做到我们想做的事情，这是所有程序项目最终的目标。

全面的思考、周密的准备、良好的构造不仅使程序更易构建与调试，也使其更易理解和维护，而那正是一套软件赢利的必要条件。

## 6) 阶段 4 ：校订

现在进入的是传统意义上称为“维护”的一个阶段。

“校订”。换言之，“你第一次做的东西并不完善，所以需为自己留下一个深入学习、认知的空间，再回过头去作一些改变”。

反复的“校订”同“递增开发”有关密不可分的关系。

## 7) 计划的回报

没有计划的50％以上的项目都会失败！

# 13 Java 还是 C++ ？

C++是一种绝对不会试图迎合某个模子的语言。特别是它的形式可以变化多端，以解决不同类型的问题。

Java能方便程序员解决应用级问题（如连网和跨平台UI等），所以它在本质上允许人们创建非常大型和灵活的代码主体。最“健壮”的类型检查及错误控制系统。

假如要使用大量现有的库（这样肯定可以提高不少的效率），或者已经有了一个坚实的C或C++代码库，那么换成 `Java` 后，反映会阻碍开发进度，而不是加快它的速度。但若想从头开始构建自己的所有代码，那么 `Java` 的简单易用就能有效地缩短开发时间。
